<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Cribbage Trainer (ACC-faithful, patched)</title>
<style>
  :root{
    --hole:22px; --gap:6px; --peg:12px; --track-width: calc((var(--hole) + var(--gap)) * 61);
  }
  *{box-sizing:border-box}
  body{font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:#0f1115;color:#e6e8ee;margin:0}
  header{padding:16px 20px;border-bottom:1px solid #232633;display:flex;gap:16px;align-items:center;flex-wrap:wrap}
  header h1{font-size:18px;margin:0;font-weight:600;letter-spacing:.2px}
  header .pill{background:#1a1e2b;border:1px solid #2a2f41;border-radius:999px;padding:6px 10px;font-size:12px}
  main{max-width:1100px;margin:20px auto;padding:0 16px 40px}
  .row{display:flex;gap:16px;align-items:center;flex-wrap:wrap;margin-bottom:12px}
  .box{background:#121623;border:1px solid #232633;border-radius:10px;padding:12px}
  .controls{display:flex;gap:12px;flex-wrap:wrap}
  .controls .group{display:flex;gap:8px;align-items:center}
  button,select,input[type="number"]{
    background:#182035;color:#e6e8ee;border:1px solid #2a2f41;border-radius:8px;
    padding:8px 10px;font:inherit;cursor:pointer
  }
  button:disabled{opacity:.5;cursor:not-allowed}
  input[type="number"]{width:76px}
  .toggle{display:flex;align-items:center;gap:6px}
  .kbd{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:12px;padding:2px 6px;border:1px solid #2a2f41;border-radius:6px;background:#0e131f}
  .status{display:flex;gap:16px;flex-wrap:wrap}
  .status .card{padding:10px 12px;border-radius:10px;background:#141a2a;border:1px solid #262b3e}
  .status .big{font-size:22px;font-weight:700}
  .board-wrap{margin-top:10px;display:grid;grid-template-columns:1fr;gap:20px}
  .track{
    width:100%;max-width:var(--track-width);padding:12px;border-radius:12px;
    background:#111522;border:1px solid #232633;position:relative;margin-inline:auto
  }
  .track .label{position:absolute;top:6px;right:10px;font-size:12px;color:#9aa3ba}
  .holes{display:grid;grid-template-columns:repeat(61, var(--hole));gap:var(--gap);place-items:center}
  .hole{width:var(--hole);height:var(--hole);border-radius:50%;background:#2a2f41;position:relative;outline:1px solid #121623}
  .hole[data-idx="0"]{box-shadow:0 0 0 2px #2f3b58 inset}
  .hole[data-idx="121"]{background:#2d3147;outline:2px solid #8cff9a}
  .peg{
    position:absolute;width:var(--peg);height:var(--peg);border-radius:50%;top:50%;left:50%;
    transform:translate(-50%,-50%);box-shadow:0 0 0 2px rgba(0,0,0,.35)
  }
  .p1.front{background:#ff4d4d}
  .p1.back{background:#ff9c9c}
  .p2.front{background:#4da3ff}
  .p2.back{background:#99caff}
  .running{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
  .seq{font-family:ui-monospace,Consolas,monospace;background:#0e131f;border:1px solid #2a2f41;padding:6px 8px;border-radius:8px;min-height:32px;display:flex;gap:6px;flex-wrap:wrap}
  .badge{padding:3px 6px;border-radius:6px;background:#1a2237;border:1px solid #2a2f41;font-size:12px}
  .hint{color:#9aa3ba;font-size:12px}
  .hr{height:1px;background:#232633;margin:14px 0}
  .grid{display:grid;grid-template-columns:repeat(13,1fr);gap:6px}
  .cardbtn{padding:10px 0}
  .muted{color:#aeb6cc}
</style>
</head>
<body>
<header>
  <h1>Cribbage Trainer</h1>
  <span class="pill">ACC-faithful movement & play scoring (patched)</span>
</header>
<main>

  <div class="row status">
    <div class="card">
      <div>Dealer: <span id="dealerLabel">P2</span> &nbsp;|&nbsp; Pone leads: <span id="leaderLabel">P1</span></div>
      <div class="hint">After a GO, the opponent may play multiple cards in a row. Pone always leads each new sequence unless GO rules dictate otherwise.</div>
    </div>
    <div class="card">
      <div>Running Count</div>
      <div class="big" id="runningCount">0</div>
    </div>
    <div class="card">
      <div>Turn</div>
      <div class="big" id="turnLabel">P1</div>
    </div>
    <div class="card">
      <div>Last Score</div>
      <div class="big" id="lastScore">—</div>
    </div>
  </div>

  <div class="board-wrap">
    <div class="track" id="trackP1">
      <div class="label">P1 Track</div>
      <div class="holes" id="holesP1"></div>
    </div>
    <div class="track" id="trackP2">
      <div class="label">P2 Track</div>
      <div class="holes" id="holesP2"></div>
    </div>
  </div>

  <div class="box" style="margin-top:18px">
    <div class="row">
      <strong>Play Phase</strong>
      <span class="hint">Click a card for the player whose turn it is. Pairs/runs/15/31/last-card peg automatically.</span>
    </div>

    <div class="row running">
      <div>Sequence:</div>
      <div class="seq" id="seqView"></div>
    </div>

    <div class="row">
      <div class="controls" style="width:100%">
        <div class="group" style="flex:1; min-width:260px">
          <div style="width:100%">
            <div class="grid">
              <button class="cardbtn" data-rank="1">A</button>
              <button class="cardbtn" data-rank="2">2</button>
              <button class="cardbtn" data-rank="3">3</button>
              <button class="cardbtn" data-rank="4">4</button>
              <button class="cardbtn" data-rank="5">5</button>
              <button class="cardbtn" data-rank="6">6</button>
              <button class="cardbtn" data-rank="7">7</button>
              <button class="cardbtn" data-rank="8">8</button>
              <button class="cardbtn" data-rank="9">9</button>
              <button class="cardbtn" data-rank="10">10</button>
              <button class="cardbtn" data-rank="11">J</button>
              <button class="cardbtn" data-rank="12">Q</button>
              <button class="cardbtn" data-rank="13">K</button>
            </div>
            <div class="hint" style="margin-top:6px">Face cards count 10 for the running total; rank still matters for pairs/runs.</div>
          </div>
        </div>

        <div class="group">
          <button id="btnGo">Go</button>
          <button id="btnResetSeq">Reset Sequence</button>
        </div>

        <div class="group">
          <button id="btnHeels">His Heels (+2 to Dealer)</button>
        </div>

        <div class="group">
          <button id="btnUndo">Undo last action</button>
          <button id="btnNewGame">New Game</button>
          <button id="btnSwapDealer">Swap Dealer</button>
        </div>

        <div class="group toggle">
          <input type="checkbox" id="chkMuggins">
          <label for="chkMuggins">Muggins (manual award)</label>
          <button id="btnMuggins" disabled>Give Muggins +X</button>
          <input type="number" id="mugginsPts" value="2" min="1" step="1" disabled>
        </div>
      </div>
    </div>
  </div>

  <div class="box" style="margin-top:18px">
    <div class="row">
      <strong>Counting Phase</strong>
      <span class="hint">Order: Pone hand → Dealer hand → Crib. Zero = no peg movement.</span>
    </div>
    <div class="controls">
      <div class="group">
        <button id="btnStartCount">Start Counting</button>
        <div class="badge" id="countStage">Not started</div>
      </div>
      <div class="group">
        <label>Pone hand</label>
        <input type="number" id="poneHand" min="0" step="1" value="0"/>
        <button id="btnCountPone" disabled>Peg Pone</button>
      </div>
      <div class="group">
        <label>Dealer hand</label>
        <input type="number" id="dealerHand" min="0" step="1" value="0"/>
        <button id="btnCountDealer" disabled>Peg Dealer</button>
      </div>
      <div class="group">
        <label>Crib (Dealer)</label>
        <input type="number" id="cribPoints" min="0" step="1" value="0"/>
        <button id="btnCountCrib" disabled>Peg Crib</button>
      </div>
    </div>
  </div>

  <div class="box" style="margin-top:18px">
    <div class="row">
      <strong>Scores</strong>
      <div class="badge">P1: <span id="scoreP1">0</span></div>
      <div class="badge">P2: <span id="scoreP2">0</span></div>
      <div class="badge">Game Hole: 121</div>
      <div id="gameMsg" class="badge muted">—</div>
    </div>
    <div class="hr"></div>
    <div class="hint">
      Only the <em>back</em> peg moves by the points scored, jumps over the front, and becomes the new front. After a GO, the opponent may play several cards in a row. “Last card +1” is awarded only when both cannot play and the count isn’t 31.
    </div>
  </div>

</main>

<script>
/* ------------------ Core State ------------------ */
const holes = 121; // 0..121
const P1 = { id:'P1', track:'holesP1', front:0, back:0 };
const P2 = { id:'P2', track:'holesP2', front:0, back:0 };
let dealer = P2;   // default
let pone = P1;
let leader = pone; // who leads a new sequence
let turn = leader; // whose turn to play a card
let sequence = []; // cards in current sequence: {player, rank, value}
let running = 0;
let heelsAvailable = true;
let goState = { active:false, caller:null, lastPlayer:null }; // GO flow
let gameOver = false;
const actionStack = []; // for Undo (all actions now)

/* ------------------ DOM ------------------ */
const holesP1 = document.getElementById('holesP1');
const holesP2 = document.getElementById('holesP2');
const dealerLabel = document.getElementById('dealerLabel');
const leaderLabel = document.getElementById('leaderLabel');
const turnLabel = document.getElementById('turnLabel');
const runningCountEl = document.getElementById('runningCount');
const seqView = document.getElementById('seqView');
const lastScoreEl = document.getElementById('lastScore');
const scoreP1 = document.getElementById('scoreP1');
const scoreP2 = document.getElementById('scoreP2');
const gameMsg = document.getElementById('gameMsg');

const btnGo = document.getElementById('btnGo');
const btnResetSeq = document.getElementById('btnResetSeq');
const btnHeels = document.getElementById('btnHeels');
const btnUndo = document.getElementById('btnUndo');
const btnNewGame = document.getElementById('btnNewGame');
const btnSwapDealer = document.getElementById('btnSwapDealer');

const chkMuggins = document.getElementById('chkMuggins');
const btnMuggins = document.getElementById('btnMuggins');
const mugginsPts = document.getElementById('mugginsPts');

const btnStartCount = document.getElementById('btnStartCount');
const countStage = document.getElementById('countStage');
const poneHand = document.getElementById('poneHand');
const dealerHand = document.getElementById('dealerHand');
const cribPoints = document.getElementById('cribPoints');
const btnCountPone = document.getElementById('btnCountPone');
const btnCountDealer = document.getElementById('btnCountDealer');
const btnCountCrib = document.getElementById('btnCountCrib');

/* ------------------ Build Tracks ------------------ */
function buildTrack(container){
  container.innerHTML = '';
  const row1 = document.createElement('div'); row1.className='holes';
  const row2 = document.createElement('div'); row2.className='holes';
  for(let i=0;i<=60;i++){ const h=document.createElement('div'); h.className='hole'; h.dataset.idx=i.toString(); row1.appendChild(h); }
  for(let i=61;i<=121;i++){ const h=document.createElement('div'); h.className='hole'; h.dataset.idx=i.toString(); row2.appendChild(h); }
  container.appendChild(row1); container.appendChild(row2);
}
buildTrack(holesP1);
buildTrack(holesP2);

function holeEl(player, idx){
  const container = (player===P1) ? holesP1 : holesP2;
  return container.querySelector(`.hole[data-idx="${idx}"]`);
}
function drawPegs(){
  [holesP1, holesP2].forEach(c=>c.querySelectorAll('.peg').forEach(p=>p.remove()));
  // P1
  [['front','p1 front'],['back','p1 back']].forEach(([w,cls])=>{
    const idx = P1[w]; const el = holeEl(P1, idx); const peg = document.createElement('div'); peg.className=`peg ${cls}`; el.appendChild(peg);
  });
  // P2
  [['front','p2 front'],['back','p2 back']].forEach(([w,cls])=>{
    const idx = P2[w]; const el = holeEl(P2, idx); const peg = document.createElement('div'); peg.className=`peg ${cls}`; el.appendChild(peg);
  });
  scoreP1.textContent = P1.front;
  scoreP2.textContent = P2.front;
}
function uiSync(){
  dealerLabel.textContent = (dealer===P1?'P1':'P2');
  leaderLabel.textContent = (leader===P1?'P1':'P2');
  turnLabel.textContent = (turn===P1?'P1':'P2');
  runningCountEl.textContent = running;
  seqView.innerHTML = sequence.map(c=>`<span class="badge">${c.player.id}:${cardLabel(c.rank)} (${c.value})</span>`).join('');
  btnHeels.disabled = !heelsAvailable || gameOver;
  btnGo.disabled = gameOver;
  btnResetSeq.disabled = gameOver;
  btnUndo.disabled = gameOver || actionStack.length===0;
  btnMuggins.disabled = !chkMuggins.checked || gameOver;
  mugginsPts.disabled = !chkMuggins.checked;
}

/* ------------------ Snapshots (Undo) ------------------ */
function snapshot(label=''){
  return {
    kind:'state',
    label,
    P1:{front:P1.front, back:P1.back},
    P2:{front:P2.front, back:P2.back},
    leader: leader.id,
    turn: turn.id,
    running,
    sequence: JSON.parse(JSON.stringify(sequence)),
    heelsAvailable,
    goState: JSON.parse(JSON.stringify(goState)),
    lastScore: lastScoreEl.textContent,
    gameOver,
    gameMsg: gameMsg.textContent
  };
}
function restore(snap){
  P1.front=snap.P1.front; P1.back=snap.P1.back;
  P2.front=snap.P2.front; P2.back=snap.P2.back;
  leader = (snap.leader==='P1')?P1:P2;
  turn = (snap.turn==='P1')?P1:P2;
  running = snap.running;
  sequence = snap.sequence;
  heelsAvailable = snap.heelsAvailable;
  goState = snap.goState;
  lastScoreEl.textContent = snap.lastScore;
  gameOver = snap.gameOver;
  gameMsg.textContent = snap.gameMsg;
  drawPegs(); uiSync();
}

/* ------------------ Utilities ------------------ */
function cardLabel(rank){ return ({11:'J',12:'Q',13:'K'}[rank] || (rank===1?'A':rank)); }
function valForRank(rank){ return Math.min(rank, 10); }
function endGameIfNeeded(player){
  if(player.front>=121){
    gameOver = true;
    gameMsg.textContent = `Game over: ${player.id} pegs out at 121`;
  }
}

/* Leapfrog: move ONLY the back peg, then swap roles */
function leapfrog(player, points, label=''){
  if(points<=0) return; // zero = no movement
  const prev = snapshot(`peg ${player.id} +${points} ${label}`);
  const target = Math.min(121, player.back + points);
  player.back = target;
  [player.front, player.back] = [player.back, player.front]; // swap
  drawPegs();
  lastScoreEl.textContent = `${player.id} +${points} ${label}`;
  endGameIfNeeded(player);
  actionStack.push(prev);
}

/* ------------------ Scoring During Play ------------------ */
function scoreRun(seq){
  // Longest tail run (k>=3), no duplicates, consecutive ranks (order ignored)
  let best = 0;
  for(let k = seq.length; k>=3; k--){
    const slice = seq.slice(-k).map(c=>c.rank);
    const set = new Set(slice);
    if(set.size !== k) continue;
    const min = Math.min(...slice), max = Math.max(...slice);
    if(max - min + 1 === k){ best = k; break; }
  }
  return best;
}

function playCard(rank){
  if(gameOver) return;

  // Snapshot BEFORE any state change (so Undo can roll back non-scoring plays too)
  actionStack.push( snapshot(`play ${turn.id} ${cardLabel(rank)}`) );

  if(heelsAvailable) heelsAvailable = false;

  const value = valForRank(rank);
  if(running + value > 31){
    alert("That would exceed 31. Press 'Go' if you cannot play.");
    actionStack.pop(); // invalid action; discard snapshot
    return;
  }

  // Register card
  sequence.push({player:turn, rank, value});
  running += value;
  goState.lastPlayer = turn;

  // Compute pegging from this play
  let gained = 0; const reasons = [];

  // Pairs/Trips/Quads on tail
  let same = 1;
  for(let i=sequence.length-2; i>=0; i--){
    if(sequence[i].rank === rank) same++;
    else break;
  }
  if(same===2){ gained += 2; reasons.push('Pair +2'); }
  else if(same===3){ gained += 6; reasons.push('Pair Royal +6'); }
  else if(same===4){ gained += 12; reasons.push('Double Pair Royal +12'); }

  // Runs
  const runPts = scoreRun(sequence);
  if(runPts>0){ gained += runPts; reasons.push(`Run of ${runPts} +${runPts}`); }

  // 15 and 31
  if(running===15){ gained += 2; reasons.push('Fifteen +2'); }
  if(running===31){ gained += 2; reasons.push('Thirty-one +2'); }

  if(gained>0){ leapfrog(turn, gained, reasons.join(', ')); }

  // Turn logic (patched):
  // - If 31: sequence ends; next leader is opponent; next turn = leader; clear GO state.
  // - Else if GO is active: opponent of caller may continue to play multiple cards (keep turn).
  // - Else: alternate turn normally.
  if(running===31){
    sequence = []; running = 0;
    leader = (turn===P1)?P2:P1; // after 31, other player leads next
    turn = leader;
    goState = {active:false, caller:null, lastPlayer:null};
  } else {
    if(goState.active){
      // Keep play with the opponent of the caller
      const opponent = (goState.caller===P1)?P2:P1;
      turn = opponent; // do NOT alternate
    } else {
      // Normal alternation
      turn = (turn===P1)?P2:P1;
    }
  }

  uiSync();
}

/* ------------------ Go / Sequence Reset ------------------ */
btnGo.addEventListener('click', ()=>{
  if(gameOver) return;

  // Snap before changing go-state
  actionStack.push( snapshot('Go button') );

  if(sequence.length===0){
    alert('No cards in sequence yet.');
    actionStack.pop();
    return;
  }

  if(goState.active){
    const other = (goState.caller===P1)?P2:P1;
    if(turn !== other){
      // It's the other player's turn to try; you shouldn't press GO here
      // but we'll accept it and treat as "both cannot play"
    }
    // Second GO => award last card +1 to last player if not 31
    if(running !== 31 && goState.lastPlayer){
      leapfrog(goState.lastPlayer, 1, 'Last card +1');
    }
    // Reset sequence; initial GO-caller leads next
    sequence = []; running = 0;
    leader = goState.caller;
    turn = leader;
    goState = {active:false, caller:null, lastPlayer:null};
  } else {
    // First GO: mark and pass turn to opponent who may keep playing
    goState.active = true;
    goState.caller = turn;
    turn = (turn===P1)?P2:P1;
  }
  uiSync();
});

/* Manual sequence reset: no points are awarded */
btnResetSeq.addEventListener('click', ()=>{
  if(gameOver) return;
  actionStack.push( snapshot('Reset Sequence') );
  sequence = []; running = 0;
  // If GO was active, the initial GO-caller leads
  if(goState.active && goState.caller){ leader = goState.caller; }
  turn = leader;
  goState = {active:false, caller:null, lastPlayer:null};
  uiSync();
});

/* ------------------ Heels (+2 before first card) ------------------ */
btnHeels.addEventListener('click', ()=>{
  if(gameOver) return;
  if(!heelsAvailable){
    alert('Heels must be taken before the first card is played.');
    return;
  }
  actionStack.push( snapshot('Heels') );
  leapfrog(dealer, 2, 'His Heels +2');
  heelsAvailable = false;
  uiSync();
});

/* ------------------ Card Buttons ------------------ */
document.querySelectorAll('.cardbtn').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    const rank = Number(btn.dataset.rank);
    playCard(rank);
  });
});

/* ------------------ Undo (now for all actions) ------------------ */
btnUndo.addEventListener('click', ()=>{
  if(actionStack.length===0 || gameOver) return;
  const snap = actionStack.pop();
  restore(snap);
});

/* ------------------ Counting Phase ------------------ */
let counting = false, countingStep = 0; // 1: pone, 2: dealer, 3: crib
const btnStartCount = document.getElementById('btnStartCount');
btnStartCount.addEventListener('click', ()=>{
  if(gameOver){ alert('Game finished. Start a new game.'); return; }
  counting = true; countingStep = 1;
  countStage.textContent = 'Pone Hand';
  btnCountPone.disabled = false; btnCountDealer.disabled = true; btnCountCrib.disabled = true;
});

btnCountPone.addEventListener('click', ()=>{
  if(!counting || countingStep!==1) return;
  actionStack.push( snapshot('Count Pone') );
  const pts = Number(poneHand.value||0);
  if(pts>0) leapfrog(pone, pts, 'Pone hand');
  countingStep = 2; countStage.textContent = 'Dealer Hand';
  btnCountPone.disabled = true; btnCountDealer.disabled = false; uiSync();
});
btnCountDealer.addEventListener('click', ()=>{
  if(!counting || countingStep!==2) return;
  actionStack.push( snapshot('Count Dealer') );
  const pts = Number(dealerHand.value||0);
  if(pts>0) leapfrog(dealer, pts, 'Dealer hand');
  countingStep = 3; countStage.textContent = 'Crib (Dealer)';
  btnCountDealer.disabled = true; btnCountCrib.disabled = false; uiSync();
});
btnCountCrib.addEventListener('click', ()=>{
  if(!counting || countingStep!==3) return;
  actionStack.push( snapshot('Count Crib') );
  const pts = Number(cribPoints.value||0);
  if(pts>0) leapfrog(dealer, pts, 'Crib');
  counting = false; countingStep = 0;
  countStage.textContent = 'Done';
  btnCountCrib.disabled = true; uiSync();
});

/* ------------------ Muggins (manual) ------------------ */
chkMuggins.addEventListener('change', ()=>{
  btnMuggins.disabled = !chkMuggins.checked || gameOver;
  mugginsPts.disabled = !chkMuggins.checked;
});
btnMuggins.addEventListener('click', ()=>{
  if(!chkMuggins.checked || gameOver) return;
  actionStack.push( snapshot('Muggins manual') );
  const pts = Math.max(1, Number(mugginsPts.value||0));
  const beneficiary = (turn===P1)?P2:P1; // award to non-current
  leapfrog(beneficiary, pts, 'Muggins (manual)');
  uiSync();
});

/* ------------------ Game / Dealer Controls ------------------ */
btnNewGame.addEventListener('click', ()=>{ resetGame(false); });
btnSwapDealer.addEventListener('click', ()=>{
  actionStack.push( snapshot('Swap Dealer') );
  [dealer, pone] = (dealer===P1) ? [P2, P1] : [P1, P2];
  leader = pone; turn = leader; heelsAvailable = true; uiSync();
});

/* ------------------ Reset ------------------ */
function resetGame(full=true){
  actionStack.length = 0;
  [P1, P2].forEach(p=>{ p.front=0; p.back=0; });
  drawPegs();
  sequence = []; running = 0;
  heelsAvailable = true;
  goState = {active:false, caller:null, lastPlayer:null};
  gameOver = false; gameMsg.textContent = '—';
  leader = pone; turn = leader;
  if(full){ dealer = P2; pone = P1; leader = pone; turn = leader; }
  uiSync();
}

/* ------------------ Boot ------------------ */
drawPegs();
uiSync();
</script>
</body>
</html>
